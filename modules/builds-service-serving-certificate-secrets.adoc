// Module included in the following assemblies:
// * assembly/builds

[id='builds-service-serving-certificate-secrets-{context}']
= Service serving certificate secrets

Service serving certificate secrets are intended to support complex middleware
applications that need out-of-the-box certificates. It has the same settings as
the server certificates generated by the administrator tooling for nodes and
masters.

== Restrictions

To use a secret, a pod needs to reference the secret. A secret can be used with
a pod in three ways:

* To populate environment variables for containers.
* As files in a volume mounted on one or more of its containers.
* By kubelet when pulling images for the pod.

Volume type secrets write data into the container as a file using the volume
mechanism. *imagePullSecrets* use service accounts for the automatic injection of
the secret into all pods in a namespaces.

When a template contains a secret definition, the only way for the template to
use the provided secret is to ensure that the secret volume sources are
validated and that the specified object reference actually points to an object
of type `Secret`. Therefore, a secret needs to be created before any pods that
depend on it. The most effective way to ensure this is to have it get injected
automatically through the use of a service account.

Secret API objects reside in a namespace. They can only be referenced by pods in
that same namespace.

Individual secrets are limited to 1MB in size. This is to discourage the
creation of large secrets that would exhaust apiserver and kubelet memory.
However, creation of a number of smaller secrets could also exhaust memory.

.Procedure

To secure communication to your service, have the cluster generate a signed
serving certificate/key pair into a secret in your namespace.

* Set the `service.alpha.openshift.io/serving-cert-secret-name` annotation on your
service with the value set to the name you want to use for your secret.
+
Then, your `PodSpec` can mount that secret. When it is available, your pod will
run. The certificate will be good for the internal service DNS name,
`<service.name>.<service.namespace>.svc`.
+
The certificate and key are in PEM format, stored in `tls.crt` and `tls.key`
respectively. The certificate/key pair is automatically replaced when it gets
close to expiration. View the expiration date in the
`service.alpha.openshift.io/expiry` annotation on the secret, which is in
RFC3339 format.

[NOTE]
====
In most cases, the service DNS name
`<service.name>.<service.namespace>.svc` is not externally routable. The
primary use of `<service.name>.<service.namespace>.svc` is for intracluster or
intraservice communication, and with re-encrypt routes.
====

Other pods can trust cluster-created certificates (which are only signed for
internal DNS names), by using the CA bundle in the
*_/var/run/secrets/kubernetes.io/serviceaccount/service-ca.crt_* file that is
automatically mounted in their pod.

The signature algorithm for this feature is `x509.SHA256WithRSA`. To manually
rotate, delete the generated secret. A new certificate is created.
